// Copyright 2020 New Relic, Inc. All rights reserved.
// SPDX-License-Identifier: Apache-2.0

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq.Expressions;

namespace NewRelic.Agent.Core
{
    /// <summary>
    /// The class used by the byte-code injected by the profiler to invoke arbitrary methods defined in the managed agent.
    /// </summary>
    public class ProfilerAgentMethodInvoker
    {
        private static readonly ConcurrentDictionary<string, Func<object[], object>> _invokerCache = new ConcurrentDictionary<string, Func<object[], object>>();

        /// <summary>
        /// This method is invoked once using reflection by the byte-code injected by the profiler. This method is used to get a 
        /// reference to the method that is used to cache reflection lookups and Expression compilation for Agent methods.
        /// This is currently used for Agent API methods.
        /// </summary>
        /// <returns>
        /// A reference to the method that is used to invoked the requrested agent method. The result is treated as an object
        /// to simplify the type definition injected by the profiler to store this reference.
        /// </returns>
        public static object GetInvoker()
        {
            return (Func<string, string, string, Type[], Type, object[], object>)GetAndInvokeMethodFromCache;
        }

        /// <summary>
        /// This is the method that is invoked by the injected byte code for the Agent API.
        /// It uses a cache so that the more expensive operations are only executed once.
        /// This method will invoke the requested method using the specified parameters.
        /// The method will always return a value. This value will either be the result of the
        /// requested method call, or null if the requested method has a void return type.
        /// </summary>
        /// <param name="key">The cache key generated by the profiler.</param>
        /// <param name="className">The name of the type containing the static method to execute.</param>
        /// <param name="methodName">The name of the static method to execute.</param>
        /// <param name="originalTypes">An array of types that represent the type for each parameter in the method to invoke.</param>
        /// <param name="returnType">The type returned by the method to invoke. A null is used to represent a void return type.</param>
        /// <param name="originalParameters">The parameters to invoke the method with.</param>
        /// <returns>The value returned from invoking the requested method, or null if the method has a void return type.</returns>
        public static object GetAndInvokeMethodFromCache(string key, string className, string methodName, Type[] originalTypes, Type returnType, object[] originalParameters)
        {
            var types = originalTypes ?? Array.Empty<Type>();
            var parameters = originalParameters ?? Array.Empty<object>();

            if (!_invokerCache.TryGetValue(key, out var invoker))
            {
                var type = Type.GetType(className);
                var mi = type.GetMethod(methodName, types);
                var delegateType = returnType == null ? Expression.GetActionType(types) : Expression.GetFuncType(GetTypesForFunc(types, returnType));
                var methodDelegate = mi.CreateDelegate(delegateType);

                /* Create a function similar to the following code
                 * object InovkeMethod(object[] parameters) {
                 *   return methodDelegate.Invoke((types[0])parameters[0]);
                 * }
                 */
                var parametersParam = Expression.Parameter(typeof(object[]), "parameters");
                var methodToCall = Expression.Constant(methodDelegate, delegateType);
                IEnumerable<Expression> parameterExpressions = GetInvokerParameterExpressions(parametersParam, types);
                var invocationExpression = Expression.Invoke(methodToCall, parameterExpressions);

                var lambdaExpression = returnType != null ?
                    Expression.Lambda<Func<object[], object>>(invocationExpression, parametersParam) :
                    Expression.Lambda<Func<object[], object>>(Expression.Block(invocationExpression, Expression.Constant(null)), parametersParam);

                invoker = lambdaExpression.Compile();
                _invokerCache.TryAdd(key, invoker);
            }

            return invoker(parameters);
        }

        private static IEnumerable<Expression> GetInvokerParameterExpressions(Expression parametersExpression, Type[] types)
        {
            for (var i = 0; i < types.Length; i++)
            {
                var getParameterAtIndex = Expression.ArrayAccess(parametersExpression, Expression.Constant(i));
                yield return Expression.Convert(getParameterAtIndex, types[i]);
            }
        }

        private static Type[] GetTypesForFunc(Type[] parameterTypes, Type returnType)
        {
            if (parameterTypes.Length == 0)
            {
                return new Type[] { returnType };
            }

            var types = new Type[parameterTypes.Length + 1];
            Array.Copy(parameterTypes, types, parameterTypes.Length);
            types[parameterTypes.Length] = returnType;

            return types;
        }
    }
}
